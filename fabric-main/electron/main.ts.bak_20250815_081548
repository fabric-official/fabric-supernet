import { execFile, execFileSync } from "child_process";
import * as https from "https";
import * as http from "http";
import { app, BrowserWindow, ipcMain, session, Menu, crashReporter } from "electron";
import fs from "fs";
import path from "path";
import crypto from "crypto";
import QRCode from "qrcode";
import nacl from "tweetnacl";
import * as igit from "isomorphic-git";
import httpGit from "isomorphic-git/http/node";
import zlib from "zlib";
import Ajv from "ajv";
import addFormats from "ajv-formats";
import { pathToFileURL } from "url";

import { execFile } from "child_process";
/* ==== FabricSec policy/gates/secrets (idempotent) ==== */
if (!(globalThis as any).FabricSec) {
  (globalThis as any).FabricSec = (() => {
    const fs    = require("fs")    as typeof import("fs");
    const path  = require("path")  as typeof import("path");
    const crypto= require("crypto")as typeof import("crypto");
    const SITE  = path.resolve(process.cwd(), "repo", "site");
    const ROOT  = path.resolve(process.cwd(), "repo");
    const AGE_PUB = path.join(SITE, "age.pub");
    const AGE_KEY = path.join(SITE, "age.key");

    function ensureDir(p:string){ fs.mkdirSync(p,{recursive:true}); }
    function loadJSON<T>(file:string, def:T):T { try { return JSON.parse(fs.readFileSync(file,"utf8")); } catch { return def; } }
    function saveJSON(file:string, obj:any){ ensureDir(path.dirname(file)); const tmp=file+".tmp"; fs.writeFileSync(tmp, JSON.stringify(obj,null,2)); fs.renameSync(tmp,file); }

    type Gate = "agent.pkg.install"|"agent.update"|"plugin.store.install"|"network.create"|"wifi.join"|"export.artifact";
    type Policy = { toolchain?:{pin?:string}, gates?:Partial<Record<Gate,boolean>>, artifacts?:{roots?:string[]} };

    function loadPolicy():Policy {
      const file = path.join(SITE,"policy.json");
      const p = loadJSON<Policy>(file, {gates:{}, toolchain:{}, artifacts:{roots:[ROOT]}});
      p.gates     = p.gates     || {};
      p.artifacts = p.artifacts || { roots:[ROOT] };
      return p;
    }

    function isUnderRoots(absPath:string, roots:string[]=[ROOT]) {
      const p = path.normalize(path.resolve(absPath));
      return roots.some(r => p.startsWith(path.normalize(path.resolve(r)) + path.sep));
    }

    function enforceArtifactPath(absPath:string, pol:Policy) {
      const roots = pol.artifacts?.roots || [ROOT];
      if (!isUnderRoots(absPath, roots)) throw new Error(JSON.stringify({code:"PATH_DENY", path:absPath}));
    }

    function enforceGate(op:Gate){ const pol=loadPolicy(); if (!pol.gates?.[op]) throw new Error(JSON.stringify({code:"POLICY_DENY", op})); }

    function getPinnedToolchain():string|undefined { const f=path.join(SITE,"toolchain.json"); return loadJSON<{id?:string}>(f,{}).id; }
    function requireToolchain(provided?:string){
      const pinned=getPinnedToolchain();
      if (!pinned && !provided) throw new Error(JSON.stringify({code:"TOOLCHAIN_REQUIRED"}));
      if (pinned && provided && pinned!==provided) throw new Error(JSON.stringify({code:"TOOLCHAIN_MISMATCH", pinned, provided}));
    }

    function haveAge():boolean {
      try {
        const cp = require("child_process") as typeof import("child_process");
        cp.execFileSync(process.platform==="win32"?"age.exe":"age", ["-version"], {stdio:"ignore"});
        return true;
      } catch { return false; }
    }
    function ageEncrypt(plain:Buffer):Buffer {
      const cp = require("child_process") as typeof import("child_process");
      const bin = process.platform==="win32"?"age.exe":"age";
      const pub = fs.readFileSync(AGE_PUB,"utf8").trim();
      return Buffer.from(cp.execFileSync(bin, ["-r", pub], {input:plain}));
    }
    function ageDecrypt(cipher:Buffer):Buffer {
      const cp = require("child_process") as typeof import("child_process");
      const bin = process.platform==="win32"?"age.exe":"age";
      return Buffer.from(cp.execFileSync(bin, ["-d", "-i", AGE_KEY], {input:cipher}));
    }
    function dpapiProtect(plain:string):string {
      if (process.platform!=="win32"){
        const keyFile=path.join(SITE,"secrets.key");
        if(!fs.existsSync(keyFile)) fs.writeFileSync(keyFile, crypto.randomBytes(32));
        const key=fs.readFileSync(keyFile);
        const iv = crypto.randomBytes(12);
        const c = crypto.createCipheriv("aes-256-gcm", key, iv);
        const ct = Buffer.concat([c.update(Buffer.from(plain,"utf8")), c.final()]);
        const tag = c.getAuthTag();
        return "aes:"+Buffer.concat([iv,tag,ct]).toString("base64");
      }
      const ps = `
$s='${"`"}' + plain.replace(/'/g,"''") + '${"`"}';
$ss = ConvertTo-SecureString -String $s -AsPlainText -Force;
$enc = ConvertFrom-SecureString -SecureString $ss;
[Console]::Out.Write($enc)
`;
      const cp = require("child_process") as typeof import("child_process");
      const out = cp.execFileSync("powershell.exe", ["-NoProfile","-NonInteractive","-Command", ps], {encoding:"utf8"});
      return "dpapi:"+out.trim();
    }
    function dpapiUnprotect(enc:string):string {
      if (process.platform!=="win32"){
        const b=Buffer.from(enc,"base64"); const iv=b.slice(0,12), tag=b.slice(12,28), ct=b.slice(28);
        const keyFile=path.join(SITE,"secrets.key"); const key=fs.readFileSync(keyFile);
        const d=crypto.createDecipheriv("aes-256-gcm", key, iv); d.setAuthTag(tag);
        return Buffer.concat([d.update(ct), d.final()]).toString("utf8");
      }
      const ps = `
$enc='${"`"}' + enc.replace(/'/g,"''") + '${"`"}';
$ss = ConvertTo-SecureString -String $enc;
$bstr = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($ss);
try { [Runtime.InteropServices.Marshal]::PtrToStringUni($bstr) } finally { [Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr) }
`;
      const cp = require("child_process") as typeof import("child_process");
      return cp.execFileSync("powershell.exe", ["-NoProfile","-NonInteractive","-Command", ps], {encoding:"utf8"});
    }

    function encSecret(s:string):string {
      try { if (haveAge() && fs.existsSync(AGE_PUB)) return "age:"+ageEncrypt(Buffer.from(s,"utf8")).toString("base64"); } catch {}
      return dpapiProtect(s);
    }
    function decSecret(v:string):string {
      try { if (v.startsWith("age:") && haveAge() && fs.existsSync(AGE_KEY)) return ageDecrypt(Buffer.from(v.slice(4),"base64")).toString("utf8"); } catch {}
      if (v.startsWith("dpapi:")) return dpapiUnprotect(v.slice(6));
      if (v.startsWith("aes:"))   return dpapiUnprotect(v.slice(4));
      try { return Buffer.from(v,"base64").toString("utf8"); } catch { return v; }
    }
    function migrateSecretIfPossible(getter:()=>string, setter:(s:string)=>void){
      try { const plain=getter(); if(plain && haveAge() && fs.existsSync(AGE_PUB)){ setter("age:"+ageEncrypt(Buffer.from(plain,"utf8")).toString("base64")); } } catch {}
    }

    return {
      gate: (op: any)=>enforceGate(op),
      scopeFile: (p:string)=>enforceArtifactPath(p, loadPolicy()),
      requireToolchain,
      encSecret, decSecret, migrateSecretIfPossible,
      loadPolicy
    };
  })();
}
/* ==== end FabricSec ==== */

const ROOT  = path.resolve(process.cwd(), "repo");
const SITE  = path.join(ROOT, "site");
const AUDIT = path.join(ROOT, "audit");
const REG   = path.resolve(process.cwd(), "plugins/registry.json");
const LBCFG = path.join(SITE, "lbrain.json");
const GITCFG = path.join(SITE, "git.json");
const AUTHCFG = path.join(SITE, "auth.json");
const CSPOPTS = path.join(SITE, "csp.json");
const REGPIN  = path.join(SITE, "registry.pub");
const ENROLLQ = path.join(ROOT, "enrollment", "queue");

for (const d of ["audit","site","devices","revocations","licenses","seats","agents","downloads","plugins","archive","enrollment","enrollment/queue"]) {
  fs.mkdirSync(path.join(ROOT, d), { recursive: true });
}

// ---------- helpers ----------
function bomSafeReadJSON(p: string, fallback: any) {
  try { const b=fs.readFileSync(p); const bb=(b[0]===0xEF&&b[1]===0xBB&&b[2]===0xBF)?b.slice(3):b; return JSON.parse(bb.toString("utf8")); }
  catch { return fallback; }
}
function writeFileAtomic(file: string, data: string|Buffer) {
  fs.mkdirSync(path.dirname(file), { recursive: true });
  const tmp = file + ".tmp"; const fd = fs.openSync(tmp, "w");
  try { if (typeof data==="string") fs.writeFileSync(fd, data); else fs.writeFileSync(fd, data); fs.fsyncSync(fd); } finally { fs.closeSync(fd); }
  fs.renameSync(tmp, file); try { const dfd=fs.openSync(path.dirname(file),"r"); fs.fsyncSync(dfd); fs.closeSync(dfd);} catch {}
}
function sha256(buf: Buffer): string { return crypto.createHash("sha256").update(buf).digest("hex"); }
function httpGet(u: string, timeoutMs = 5000): Promise<{status:number, body:Buffer, headers:any}> {
  return new Promise((resolve, reject) => {
    const url = new URL(u); const mod = url.protocol==="https:"?https:http;
    const req = mod.get(url, res => {
      const chunks:Buffer[]=[]; res.on("data", d=>chunks.push(Buffer.isBuffer(d)?d:Buffer.from(d)));
      res.on("end", ()=>resolve({ status:res.statusCode||0, body:Buffer.concat(chunks), headers:res.headers }));
    }); req.on("error", reject); req.setTimeout(timeoutMs, ()=>{ req.destroy(new Error("timeout")); });
  });
}
function httpJson(u:string, t=5000){ return httpGet(u,t).then(r=>{ if(r.status>=400) throw new Error("HTTP "+r.status); const b=(r.body[0]===0xEF&&r.body[1]===0xBB&&r.body[2]===0xBF)?r.body.slice(3):r.body; return JSON.parse(b.toString("utf8")); }); }
function gzipFile(src:string, dst:string){ return new Promise<void>((resolve,reject)=>{ fs.createReadStream(src).pipe(zlib.createGzip()).pipe(fs.createWriteStream(dst)).on("error",reject).on("finish",()=>resolve()); }); }

// ---------- crash/metrics ----------
crashReporter.start({ companyName: "SuperNet", productName: "Fabric Dashboard", submitURL: "file://", uploadToServer: false, compress: true, ignoreSystemCrashHandler: true });

// ---------- secrets (DPAPI optional; secretbox fallback) ----------
const SBX_KEY = path.join(SITE, "host.secretbox.key");
function ensureSbxKey(): Buffer { try{ if(fs.existsSync(SBX_KEY)) return fs.readFileSync(SBX_KEY);}catch{} const k=crypto.randomBytes(32); writeFileAtomic(SBX_KEY,k); return k; }
function encSecret(plain: string): string {
  try { const DP = require("win-dpapi"); const out = DP.protectData(Buffer.from(plain,"utf8"), null, "CurrentUser"); return "dpapi1:"+Buffer.from(out).toString("base64"); } catch {}
  const key = ensureSbxKey(); const nonce = crypto.randomBytes(24); const msg = Buffer.from(plain,"utf8");
  const box = nacl.secretbox(new Uint8Array(msg), new Uint8Array(nonce), new Uint8Array(key));
  return "sbx1:"+Buffer.from(nonce).toString("base64")+":"+Buffer.from(Buffer.from(box)).toString("base64");
}
function decSecret(token: string): string {
  try{
    if(!token) return "";
    if(token.startsWith("dpapi1:")){ const DP=require("win-dpapi"); const b=Buffer.from(token.slice(7),"base64"); const out=(DP.unprotectData?DP.unprotectData(b,null,"CurrentUser"):DP.unprotect(b,null,"CurrentUser")); return Buffer.isBuffer(out)?out.toString("utf8"):Buffer.from(out).toString("utf8"); }
    if(token.startsWith("sbx1:")){ const [_,nB,cB]=token.split(":"); const nonce=Buffer.from(nB,"base64"); const box=Buffer.from(cB,"base64"); const key=ensureSbxKey(); const out=nacl.secretbox.open(new Uint8Array(box), new Uint8Array(nonce), new Uint8Array(key)); return out?Buffer.from(out).toString("utf8"):""; }
    return "";
  }catch{ return ""; }
}

// ---------- LB health / circuit-backoff ----------
function getLbUrl(): string { const env=process.env.LBRAIN_URL; if(env) return env; const j=bomSafeReadJSON(LBCFG,{}); return j.url||"http://127.0.0.1:8891"; }
let lbState:{status:"connected"|"degraded"|"down"; lastErr?:string; lastOkAt?:string}={status:"down"};
async function lbHealthOnce(): Promise<boolean> {
  try{ const base=getLbUrl().replace(/\/+$/,""); const j=await httpJson(base+"/healthz",4000); const ok=(j&&(j.ok===true||j.status==="ok"));
       lbState.status=ok?"connected":"degraded"; lbState.lastOkAt=ok?new Date().toISOString():lbState.lastOkAt; lbState.lastErr=ok?"":"healthz not ok"; return ok; }
  catch(e:any){ lbState.status="down"; lbState.lastErr=String(e?.message||e); return false; }
}
function scheduleLbHealth(){ let delay=1000; const tick=async()=>{ const ok=await lbHealthOnce(); delay = ok?5000:Math.min(60000, delay*2); setTimeout(tick, delay); }; tick(); }

// ---------- tight CSP (allowlist localhost ports) ----------
function connectSrcAllow(): string {
  const cfg=bomSafeReadJSON(CSPOPTS,{ ports:[8891] }); const ports=Array.isArray(cfg.ports)?cfg.ports:[8891];
  return ports.map((p:number)=>`http://127.0.0.1:${p}`).join(" ");
}
function setCsp(sess:any){
  const allow=connectSrcAllow();
  sess.webRequest.onHeadersReceived((details:any,cb:any)=>{ const csp=`default-src 'self'; script-src 'self'; connect-src 'self' ${allow}; img-src 'self' data:; object-src 'none'; frame-ancestors 'none'; require-trusted-types-for 'script';`; cb({ responseHeaders:{...details.responseHeaders,"Content-Security-Policy":[csp]} }); });
}

// ---------- provenance sign/verify + rotation ----------
const SK = path.join(SITE, "host-signing.key");
const PK = path.join(SITE, "host-signing.pub");
const KEYMETA = path.join(SITE, "host-signing.meta.json");
function ensureHostKeys(){ try{ const has=fs.existsSync(SK)&&fs.existsSync(PK); if(!has){ const kp=nacl.sign.keyPair(); writeFileAtomic(SK,Buffer.from(kp.secretKey).toString("hex")); writeFileAtomic(PK,Buffer.from(kp.publicKey).toString("hex")); writeFileAtomic(KEYMETA,Buffer.from(JSON.stringify({created:new Date().toISOString(),rotated:null},null,2),"utf8")); } }catch{} }
function hostSignHex(buf:Buffer){ ensureHostKeys(); const skHex=fs.readFileSync(SK,"utf8").trim(); const sk=Buffer.from(skHex,"hex"); const sig=nacl.sign.detached(new Uint8Array(buf), new Uint8Array(sk)); return Buffer.from(sig).toString("hex"); }
function hostVerifyHex(buf:Buffer,sigHex:string){ try{ const pkHex=fs.readFileSync(PK,"utf8").trim(); const pk=Buffer.from(pkHex,"hex"); return nacl.sign.detached.verify(new Uint8Array(buf), new Uint8Array(Buffer.from(sigHex,"hex")), new Uint8Array(pk)); }catch{ return false; } }
function appendDelta(delta:any){ try{ const base={ ts:new Date().toISOString(), ...delta }; const payload=Buffer.from(JSON.stringify(base),"utf8"); const sig=hostSignHex(payload); const line=JSON.stringify({...base,sig})+"\n"; const f=path.join(AUDIT,new Date().toISOString().slice(0,10)+".ndjson"); const fd=fs.openSync(f,"a"); try{ fs.writeFileSync(fd,line); fs.fsyncSync(fd);} finally{ fs.closeSync(fd);} }catch{} }
function rotateHostKeysDaily(){ try{ ensureHostKeys(); const meta=bomSafeReadJSON(KEYMETA,{created:null,rotated:null}); const last=(meta.rotated||meta.created||new Date().toISOString()).slice(0,10); const today=new Date().toISOString().slice(0,10); if(last!==today){ const kp=nacl.sign.keyPair(); writeFileAtomic(SK,Buffer.from(kp.secretKey).toString("hex")); writeFileAtomic(PK,Buffer.from(kp.publicKey).toString("hex")); writeFileAtomic(KEYMETA,Buffer.from(JSON.stringify({...meta,rotated:new Date().toISOString()},null,2),"utf8")); appendDelta({type:"HostKeyRotated",payload:{}}); } }catch{} }

// ---------- registry trust pin ----------
function verifyRegistrySignature(doc:any): boolean {
  try{
    if(!fs.existsSync(REGPIN)) return true; // if not pinned yet, allow
    const pkHex=fs.readFileSync(REGPIN,"utf8").trim(); const pk=Buffer.from(pkHex,"hex");
    const { plugins, signature } = doc||{}; if(!signature || !Array.isArray(plugins)) return false;
    const payload=Buffer.from(JSON.stringify({plugins}),"utf8");
    return nacl.sign.detached.verify(new Uint8Array(payload), new Uint8Array(Buffer.from(String(signature),"hex")), new Uint8Array(pk));
  }catch{ return false; }
}
type RegPlugin = { id:string; name:string; path:string; checksum:string; enabled?:boolean; version?:string };
type RegDoc = { plugins: RegPlugin[]; signature?:string };
function loadRegistry(): RegDoc {
  if (!fs.existsSync(REG)) return { plugins: [] };
  const doc = bomSafeReadJSON(REG, { plugins: [] });
  if (!verifyRegistrySignature(doc)) { appendDelta({type:"RegistrySignatureInvalid",payload:{}}); return { plugins: [] }; }
  const reg = doc as RegDoc; reg.plugins = (reg.plugins||[]).map(p=>({ enabled:true, ...p }));
  return reg;
}
function saveRegistry(reg: RegDoc) { writeFileAtomic(REG, Buffer.from(JSON.stringify(reg, null, 2), "utf8")); }
function broadcast(channel:string, payload:any){ for(const w of BrowserWindow.getAllWindows()) w.webContents.send(channel, payload); }
function verifyPluginsOnLaunch(){ const reg=loadRegistry(); let changed=false; for(const p of reg.plugins||[]){ try{ if(!fs.existsSync(p.path)){ p.enabled=false; appendDelta({type:"PluginMissing",payload:{id:p.id}}); changed=true; continue; } const sum=sha256(fs.readFileSync(p.path)); if(String(sum).toLowerCase()!==String(p.checksum||"").toLowerCase()){ p.enabled=false; appendDelta({type:"PluginChecksumMismatch",payload:{id:p.id}}); changed=true; } }catch{} } if(changed){ saveRegistry(reg); broadcast("fabric.plugins.changed", reg.plugins); } }

// ---------- policy validation (minimal scaffold) ----------
const ajv = addFormats(new Ajv({ allErrors:true }));
const policySchema = {
  type:"object",
  properties:{
    forkable:{ type:"boolean" },
    distribution:{ type:"string", enum:["open","closed"] },
    allowedTargets:{ type:"array", items:{ type:"string" } },
    exportScopes:{ type:"array", items:{ type:"string" } }
  },
  additionalProperties:true
};
const validatePolicySchema = ajv.compile(policySchema);
function readPolicy(agentId:string): any {
  const p = path.join(ROOT,"agents",agentId,"policy.json");
  if (!fs.existsSync(p)) return {};
  return bomSafeReadJSON(p,{});
}
function validatePolicyFor(op:string, agentId:string): { ok:boolean; errors:string[] } {
  const pol = readPolicy(agentId)||{}; const errs:string[]=[];
  if(!validatePolicySchema(pol)){ errs.push("schema:"+JSON.stringify(validatePolicySchema.errors)); }
  const distribution=String(pol.distribution||"open"); const forkable=!!pol.forkable;
  if(!forkable && op==="fork") errs.push("forkable:false blocks fork");
  if(distribution==="closed" && (op==="publish"||op==="export")) errs.push("distribution:closed blocks "+op);
  if(Array.isArray(pol.allowedTargets)&&pol.allowedTargets.length && !pol.allowedTargets.includes("host")) errs.push("target 'host' not allowed");
  if(Array.isArray(pol.exportScopes)&& op==="export" && pol.exportScopes.length===0) errs.push("exportScopes empty");
  return { ok: errs.length===0, errors: errs };
}
function policyDeny(errors:string[]){ throw new Error(JSON.stringify({ code:"POLICY_VIOLATION", errors })); }

// ---------- toolchain pin (scaffold) ----------
function requireToolchain(expected?:string){
  const tool=bomSafeReadJSON(path.join(SITE,"toolchain.json"),{});
  if(expected && tool?.id!==expected) throw new Error(JSON.stringify({code:"TOOLCHAIN_MISMATCH", expected, actual: tool?.id||null}));
}

// ---------- retention + CRL watch ----------
const ATOMIC_PUBKEY = ""; let lastCrlMtime=0;
function scheduleRetention(days=90){
  const run = async ()=>{ try{ const keep=Date.now()-days*24*60*60*1000;
    if(fs.existsSync(AUDIT)){ for(const f of fs.readdirSync(AUDIT).filter(n=>n.endsWith(".ndjson"))){
      const p=path.join(AUDIT,f); const st=fs.statSync(p); const gz=path.join(ROOT,"archive",f+".gz");
      if(st.mtimeMs<keep){ if(!fs.existsSync(gz)){ try{ await gzipFile(p,gz);}catch{} } try{ fs.unlinkSync(p);}catch{} }
    } }
  }catch{} };
  run(); setInterval(run, 6*60*60*1000);
}
function scheduleCrlWatch(){
  const crlPath=path.join(ROOT,"revocations","CRL.json");
  const check=()=>{ try{
    if(!fs.existsSync(crlPath)) return; const st=fs.statSync(crlPath); if(st.mtimeMs<=lastCrlMtime) return; lastCrlMtime=st.mtimeMs;
    const doc=bomSafeReadJSON(crlPath,{}); let verified=false;
    if(ATOMIC_PUBKEY && doc?.signature){ const payload=Buffer.from(JSON.stringify({revoked:doc.revoked||[]}),"utf8");
      verified=nacl.sign.detached.verify(new Uint8Array(payload), new Uint8Array(Buffer.from(String(doc.signature),"hex")), new Uint8Array(Buffer.from(ATOMIC_PUBKEY,"hex")));
    } appendDelta({ type:"CRLUpdate", payload:{ count:(doc?.revoked||[]).length, verified } });
  }catch(e:any){ appendDelta({type:"CRLError",payload:{error:String(e?.message||e)}}); } };
  check(); setInterval(check,60*1000);
}

// ---------- auth / RBAC ----------
let sessionAuthOK=false;
function setPasscode(code:string){
  const salt=crypto.randomBytes(16); const key=crypto.scryptSync(Buffer.from(code,"utf8"), salt, 32);
  writeFileAtomic(AUTHCFG, Buffer.from(JSON.stringify({ salt: salt.toString("hex"), hash: Buffer.from(key).toString("hex") },null,2),"utf8"));
}
function verifyPasscode(code:string){
  const j=bomSafeReadJSON(AUTHCFG,null); if(!j) return false;
  const key=crypto.scryptSync(Buffer.from(code,"utf8"), Buffer.from(j.salt,"hex"), 32);
  return Buffer.from(key).toString("hex")===String(j.hash);
}
function requireAuth(){ if(!sessionAuthOK) throw new Error(JSON.stringify({code:"AUTH_REQUIRED"})); }

// ---------- helpers used by runtime ----------
async function createNetwork(name:string, psk:string){
  if (!/^[ -~]{1,32}$/.test(name)) throw new Error(JSON.stringify({code:"VALIDATION", msg:"ssid"}));
  if (psk.length < 8 || psk.length > 63) throw new Error(JSON.stringify({code:"VALIDATION", msg:"psk"}));
  const rec = { ssid: name, pskEnc: encSecret(psk), updated_at: new Date().toISOString() };
  writeFileAtomic(path.join(SITE, "network.json"), Buffer.from(JSON.stringify(rec, null, 2), "utf8"));
  const histPath = path.join(SITE,"network_history.json"); const hist=bomSafeReadJSON(histPath,[]);
  hist.unshift({ ssid:name, rotated_at:new Date().toISOString() });
  writeFileAtomic(histPath, Buffer.from(JSON.stringify(hist.slice(0,10), null, 2), "utf8"));
  const esc=(s:string)=>s.replace(/([\\;,:"])/g,"\\$1"); const wifi=`WIFI:T:WPA;S:${esc(name)};P:${esc(psk)};;`;
  const qr = await QRCode.toDataURL(wifi);
  return { ok:true, ssid:name, qr };
}

// ---------- app ----------
app.disableHardwareAcceleration();
app.whenReady().then(async ()=>{
  Menu.setApplicationMenu(null);

  const ses=session.defaultSession;
  ses.setPermissionRequestHandler((_wc:any,_perm:any,cb:any)=>cb(false));
  setCsp(ses);

  const win=new BrowserWindow({ webPreferences:{ preload:path.join(__dirname,"preload.cjs"), contextIsolation:true, nodeIntegration:false }, backgroundColor:"#0b0f19" });
  const idx = path.join(process.cwd(), "dist", "index.html");
  const fileUrl = pathToFileURL(idx).toString() + "#/apps";
  await win.loadURL(fileUrl);

  verifyPluginsOnLaunch(); scheduleLbHealth(); rotateHostKeysDaily(); scheduleRetention(90); scheduleCrlWatch();

  // LBrain
  ipcMain.handle("lbrain.status", ()=>lbState);
  ipcMain.handle("lbrain.setUrl", (_e,{url})=>{ writeFileAtomic(LBCFG, Buffer.from(JSON.stringify({url:String(url||"")},null,2),"utf8")); lbHealthOnce(); return {ok:true}; });

  // Auth
  ipcMain.handle("auth.setPasscode", (_e,{code})=>{ setPasscode(String(code||"")); return {ok:true}; });
  ipcMain.handle("auth.login", (_e,{code})=>{ const ok=verifyPasscode(String(code||"")); sessionAuthOK=ok; return {ok}; });
  ipcMain.handle("auth.status", ()=>({ ok: sessionAuthOK }));

  // Plugins
  ipcMain.handle("fabric.plugins.list", ()=>loadRegistry().plugins);
  ipcMain.handle("fabric.plugins.installLocal", (_e,{folder})=>{
    requireAuth();
    const base=path.resolve(folder); const entry=path.join(base,"dist","entry.js"); const manifest=path.join(base,"dashboard-app.json");
    if(!fs.existsSync(entry)||!fs.existsSync(manifest)) throw new Error("Missing dist/entry.js or dashboard-app.json");
    const man=bomSafeReadJSON(manifest,{}); const sum=sha256(fs.readFileSync(entry)); const reg=loadRegistry();
    reg.plugins=(reg.plugins||[]).filter(p=>p.id!==man.id); reg.plugins.push({ id:man.id, name:man.name||man.id, path:entry, checksum:sum, enabled:true });
    saveRegistry(reg); broadcast("fabric.plugins.changed", reg.plugins); return {ok:true,id:man.id};
  });
  ipcMain.handle("fabric.plugins.installFromUrl", async (_e,info)=>{
    requireAuth();
    const { id,name,entryUrl,manifestUrl,checksum } = info||{}; if(!id||!entryUrl||!manifestUrl||!checksum) throw new Error("Missing fields");
    const [entryBuf, manifestBuf] = await Promise.all([httpGet(entryUrl).then(r=>r.body), httpGet(manifestUrl).then(r=>r.body)]);
    const calc=sha256(entryBuf); if(calc.toLowerCase()!==String(checksum).toLowerCase()) throw new Error("Checksum mismatch");
    const base=path.resolve(path.join(process.cwd(),"plugins",id)); fs.mkdirSync(path.join(base,"dist"),{recursive:true});
    writeFileAtomic(path.join(base,"dist","entry.js"), entryBuf); writeFileAtomic(path.join(base,"dashboard-app.json"), manifestBuf);
    const reg=loadRegistry(); const pth=path.join(base,"dist","entry.js"); reg.plugins=(reg.plugins||[]).filter(p=>p.id!==id);
    reg.plugins.push({ id, name:name||id, path:pth, checksum:calc, enabled:true }); saveRegistry(reg); broadcast("fabric.plugins.changed", reg.plugins); return {ok:true,id};
  });
  ipcMain.handle("fabric.plugins.enable", (_e,{id,enabled})=>{ requireAuth(); const reg=loadRegistry(); const p=(reg.plugins||[]).find(x=>x.id===id); if(!p) throw new Error("Not found"); p.enabled=!!enabled; saveRegistry(reg); broadcast("fabric.plugins.changed", reg.plugins); return {ok:true}; });
  ipcMain.handle("fabric.plugins.remove", (_e,{id})=>{ requireAuth(); const reg=loadRegistry(); reg.plugins=(reg.plugins||[]).filter(x=>x.id!==id); saveRegistry(reg); broadcast("fabric.plugins.changed", reg.plugins); return {ok:true,removed:id}; });
  ipcMain.handle("fabric.plugins.cleanup", ()=>{ requireAuth(); const reg=loadRegistry(); let changed=false; for(const p of reg.plugins||[]){ if(!fs.existsSync(p.path)){ p.enabled=false; changed=true; appendDelta({type:"PluginMissing",payload:{id:p.id}}); } } if(changed){ saveRegistry(reg); broadcast("fabric.plugins.changed", reg.plugins); } return {ok:true, changed}; });

  // Git
  function gitCfg(): any { try { return fs.existsSync(GITCFG) ? JSON.parse(fs.readFileSync(GITCFG,"utf8")) : null; } catch { return null; } }
  function gitSetConfig(url:string, branch:string, username:string, password:string){ requireAuth(); const rec={ url:String(url||""), branch:String(branch||"main"), usernameEnc:encSecret(String(username||"")), passwordEnc:encSecret(String(password||"")) }; writeFileAtomic(GITCFG,Buffer.from(JSON.stringify(rec,null,2),"utf8")); appendDelta({type:"GitConfigSet",payload:{url:rec.url,branch:rec.branch}}); return {ok:true}; }
  async function gitPull(){ const cfg=gitCfg(); if(!cfg?.url) throw new Error("No remote configured"); await igit.pull({ fs, http:(httpGit as any), dir:ROOT, url:cfg.url, ref:cfg.branch||"main", singleBranch:true, fastForward:true, onAuth:()=>({ username:decSecret(cfg.usernameEnc||""), password:decSecret(cfg.passwordEnc||"") }) }); appendDelta({type:"GitPull",payload:{url:cfg.url,ref:cfg.branch||"main"}}); return {ok:true}; }
  async function gitPush(){ const cfg=gitCfg(); if(!cfg?.url) throw new Error("No remote configured"); await igit.push({ fs, http:(httpGit as any), dir:ROOT, url:cfg.url, ref:cfg.branch||"main", onAuth:()=>({ username:decSecret(cfg.usernameEnc||""), password:decSecret(cfg.passwordEnc||"") }) }); appendDelta({type:"GitPush",payload:{url:cfg.url,ref:cfg.branch||"main"}}); return {ok:true}; }
  ipcMain.handle("git.config.set", (_e,args)=>gitSetConfig(args.url,args.branch,args.username,args.password));
  ipcMain.handle("git.pull", async ()=>{ requireAuth(); return await gitPull(); });
  ipcMain.handle("git.push", async ()=>{ requireAuth(); return await gitPush(); });

  // Devices
  function listDevices(){ const dir=path.join(ROOT,"devices"); if(!fs.existsSync(dir)) return []; const files=fs.readdirSync(dir).filter(f=>f.endsWith(".json")); return files.map(f=>{ try{ return bomSafeReadJSON(path.join(dir,f),{});}catch{ return {}; }}); }
  setInterval(()=>{ broadcast("devices.update", listDevices()); }, 7000);
  ipcMain.handle("device.list", ()=>listDevices());
  ipcMain.handle("device.detail", (_e,{id})=>{ const p=path.join(ROOT,"devices",id+".json"); return fs.existsSync(p)?bomSafeReadJSON(p,{}):null; });
  ipcMain.handle("device.rename", (_e,{id,name})=>{ requireAuth(); if(!id||!name) throw new Error(JSON.stringify({code:"VALIDATION"})); const p=path.join(ROOT,"devices",id+".json"); if(!fs.existsSync(p)) throw new Error(JSON.stringify({code:"NOT_FOUND"})); const doc=bomSafeReadJSON(p,{}); doc.name=String(name); doc.updated_at=new Date().toISOString(); writeFileAtomic(p,Buffer.from(JSON.stringify(doc,null,2),"utf8")); appendDelta({type:"DeviceRenamed",payload:{id,name}}); return {ok:true}; });
  ipcMain.handle("device.remove", (_e,{id})=>{ requireAuth(); if(!id) throw new Error(JSON.stringify({code:"VALIDATION"})); const p=path.join(ROOT,"devices",id+".json"); if(fs.existsSync(p)) fs.unlinkSync(p); appendDelta({type:"DeviceRemoved",payload:{id}}); return {ok:true}; });

  // Enrollment (simple queue; challenge stub)
  ipcMain.handle("enroll.challenge", (_e,{fp})=>{ const ch=crypto.randomBytes(16).toString("hex"); writeFileAtomic(path.join(ENROLLQ, fp+".challenge"), Buffer.from(ch,"utf8")); return { ok:true, challenge:ch }; });
    ipcMain.handle("enroll.request", (_e,{fp,pub,proof})=>{
    const req={ fp:String(fp||""), pub:String(pub||""), proof:String(proof||""), ts:new Date().toISOString() };
    if(!req.fp||!req.pub||!req.proof) throw new Error(JSON.stringify({code:"VALIDATION"}));
    const chPath = path.join(ENROLLQ, req.fp + ".challenge");
    if(!fs.existsSync(chPath)) throw new Error(JSON.stringify({code:"CHALLENGE_MISSING"}));
    const challenge = fs.readFileSync(chPath, "utf8").trim();
    const ok = nacl.sign.detached.verify(
      new Uint8Array(Buffer.from(challenge,"utf8")),
      new Uint8Array(Buffer.from(req.proof,"hex")),
      new Uint8Array(Buffer.from(req.pub,"hex"))
    );
    if(!ok) throw new Error(JSON.stringify({code:"PROOF_INVALID"}));
    try { fs.unlinkSync(chPath); } catch {}
    writeFileAtomic(path.join(ENROLLQ, req.fp+".json"), Buffer.from(JSON.stringify(req,null,2),"utf8"));
    appendDelta({type:"EnrollRequested",payload:{fp:req.fp, verified:true}});
    return {ok:true, verified:true};
  }); return {ok:true}; });
ipcMain.handle("fabric.runtime.invoke", async (_e, { cmd, args }) => {
  // FabricSec gates/pin prelude
  try {
    const Sec = (globalThis as any).FabricSec;
    if (Sec) {
      const __auth  = new Set(["agent.pkg.install","agent.update","network.create","wifi.join","plugin.store.install"]);
      if (__auth.has(cmd as any)) { try { (requireAuth as any)?.(); } catch {} }
      const __gates = new Set(["agent.pkg.install","agent.update","network.create","wifi.join","plugin.store.install","export.artifact"]);
      if (__gates.has(cmd as any)) { Sec.gate(cmd as any); }
      const __pin   = new Set(["agent.pkg.install","agent.update"]);
      if (__pin.has(cmd as any)) { Sec.requireToolchain((args as any)?.toolchainId); }
    }
  } catch {}

  switch (cmd) {
    default: return { ok:false, code:"UNKNOWN_CMD", cmd };
  }
});

/* ==== ENROLL: signed challenge + request (idempotent) ==== */
try { ipcMain.removeHandler("enroll.challenge"); } catch {}
try { ipcMain.removeHandler("enroll.request"); } catch {}

ipcMain.handle("enroll.challenge", async (_e, { fp }) => {
  try {
    const ROOT = path.resolve(process.cwd(), "repo");
    const SITE = path.join(ROOT, "site");
    const chalDir = path.join(SITE, "enroll_challenges");
    fs.mkdirSync(chalDir, { recursive: true });

    const id = String(fp || "").trim();
    if (!id) throw new Error("VALIDATION");

    const nonce = crypto.randomBytes(32).toString("hex");
    const ts = new Date().toISOString();
    const body = { fp: id, nonce, ts };

    fs.writeFileSync(path.join(chalDir, `${id}.json`), JSON.stringify(body, null, 2), "utf8");
    return { ok: true, ...body };
  } catch (e:any) {
    return { ok: false, error: String(e?.message || e) };
  }
});

ipcMain.handle("enroll.request", async (_e, { fp, pub, proof }) => {
  try {
    const ROOT = path.resolve(process.cwd(), "repo");
    const SITE = path.join(ROOT, "site");
    const chalDir = path.join(SITE, "enroll_challenges");
    const pendDir = path.join(ROOT, "devices", "pending");
    fs.mkdirSync(pendDir, { recursive: true });

    const id   = String(fp   || "").trim();
    const phex = String(pub  || "").trim();
    const shex = String(proof|| "").trim();
    if (!id || !phex || !shex) throw new Error("VALIDATION");

    const chalPath = path.join(chalDir, `${id}.json`);
    if (!fs.existsSync(chalPath)) throw new Error("NO_CHALLENGE");

    const chal = JSON.parse(fs.readFileSync(chalPath, "utf8"));
    const msg  = Buffer.from(`${chal.fp}|${chal.nonce}|${chal.ts}`, "utf8");
    const ok   = nacl.sign.detached.verify(
      new Uint8Array(msg),
      new Uint8Array(Buffer.from(shex, "hex")),
      new Uint8Array(Buffer.from(phex, "hex"))
    );
    if (!ok) throw new Error("BAD_SIGNATURE");

    // queue for admin approval
    const rec = { fp: id, pub: phex, requested_at: new Date().toISOString() };
    fs.writeFileSync(path.join(pendDir, `${id}.json`), JSON.stringify(rec, null, 2), "utf8");

    try { fs.unlinkSync(chalPath); } catch {}
    return { ok: true, queued: true };
  } catch (e:any) {
    return { ok: false, error: String(e?.message || e) };
  }
});
/* ==== AUDIT EXPORT: gate + scope (idempotent) ==== */
try { ipcMain.removeHandler("audit.export.today"); } catch {}
ipcMain.handle("audit.export.today", async () => {
  const Sec = (globalThis as any).FabricSec;
  try { Sec?.gate("export.artifact"); } catch (e) { throw e; }

  const ROOT = path.resolve(process.cwd(), "repo");
  const out  = path.join(ROOT, "downloads", `audit-${new Date().toISOString().slice(0,10)}.ndjson`);
  try { Sec?.scopeFile(out); } catch (e) { throw e; }

  fs.mkdirSync(path.dirname(out), { recursive: true });
  const todays = path.join(ROOT, "audit", `${new Date().toISOString().slice(0,10)}.ndjson`);
  const data   = fs.existsSync(todays) ? fs.readFileSync(todays) : Buffer.from("");
  fs.writeFileSync(out, data);
  return { ok: true, file: out };
});
/* ==== GIT: encrypted config + safe pull/push (idempotent) ==== */
try { ipcMain.removeHandler("git.config.set"); } catch {}
try { ipcMain.removeHandler("git.pull"); } catch {}
try { ipcMain.removeHandler("git.push"); } catch {}

ipcMain.handle("git.config.set", async (_e, { url, branch, username, password }) => {
  const ROOT = path.resolve(process.cwd(), "repo");
  const cfgPath = path.join(ROOT, "site", "git.json");
  fs.mkdirSync(path.dirname(cfgPath), { recursive: true });

  const Sec = (globalThis as any).FabricSec;
  const enc = (s:string)=> Sec?.encSecret(String(s||"")) ?? String(s||"");

  const cfg = {
    url: String(url || ""),
    branch: String(branch || "main"),
    username: String(username || ""),
    password: enc(String(password || "")) // encrypted at rest
  };
  fs.writeFileSync(cfgPath, JSON.stringify(cfg, null, 2), "utf8");
  return { ok: true };
});

function __readGitConfig() {
  const ROOT = path.resolve(process.cwd(), "repo");
  const cfgPath = path.join(ROOT, "site", "git.json");
  const Sec = (globalThis as any).FabricSec;
  const dec = (v:string)=> Sec?.decSecret(String(v||"")) ?? String(v||"");
  if (!fs.existsSync(cfgPath)) return { url:"", branch:"main", username:"", password:"" };
  const j = JSON.parse(fs.readFileSync(cfgPath, "utf8"));
  try {
    if (j.password && !/^age:|^dpapi:|^aes:/.test(String(j.password))) {
      const enc = Sec?.encSecret(String(j.password)) ?? String(j.password);
      j.password = enc;
      fs.writeFileSync(cfgPath, JSON.stringify(j, null, 2), "utf8");
    }
  } catch {}
  return { ...j, password: dec(j.password||"") };
}

ipcMain.handle("git.pull", async () => {
  const ROOT = path.resolve(process.cwd(), "repo");
  const { url, branch, username, password } = __readGitConfig();
  if (!url) return { ok:false, error:"CONFIG_MISSING" };
  try { const u = new URL(url); if (u.protocol !== "https:") throw new Error("HTTPS_REQUIRED"); } catch(e:any){ return { ok:false, error:String(e.message||e) }; }

  const env:any = { ...process.env };
  if (username && password) {
    env.GIT_ASKPASS = "";
    env.GIT_USERNAME = username;
    env.GIT_PASSWORD = password;
  }
  const run = (cmd:string, args:string[]) => new Promise<{code:number,out:string}>(res=>{
    const p = execFile(cmd, args, { cwd: ROOT, env }, (_e, stdout, stderr)=>{
      res({ code: 0, out: String(stdout||"")+String(stderr||"") });
    });
    p.on("error", ()=>res({code:1,out:"exec error"}));
  });

  await run("git", ["init"]);
  await run("git", ["remote","remove","origin"]);
  await run("git", ["remote","add","origin", url]);
  await run("git", ["fetch","origin", branch]);
  await run("git", ["stash","push","-u","-m","pre-pull"]);
  await run("git", ["reset","--hard","origin/"+branch]);
  await run("git", ["stash","apply"]).catch(()=>({}));
  return { ok:true };
});

ipcMain.handle("git.push", async () => {
  const ROOT = path.resolve(process.cwd(), "repo");
  const { url, branch, username, password } = __readGitConfig();
  if (!url) return { ok:false, error:"CONFIG_MISSING" };

  const env:any = { ...process.env };
  if (username && password) {
    env.GIT_ASKPASS = "";
    env.GIT_USERNAME = username;
    env.GIT_PASSWORD = password;
  }
  const run = (cmd:string, args:string[]) => new Promise<{code:number,out:string}>(res=>{
    const p = execFile(cmd, args, { cwd: ROOT, env }, (_e, stdout, stderr)=>{
      res({ code: 0, out: String(stdout||"")+String(stderr||"") });
    });
    p.on("error", ()=>res({code:1,out:"exec error"}));
  });

  await run("git", ["add","."]);
  await run("git", ["commit","-m","chore: local changes"]).catch(()=>({}));
  const r = await run("git", ["push","origin", "HEAD:"+branch]);
  return { ok:true, out: r.out };
});
